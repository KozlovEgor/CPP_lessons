    0.  Сигнатура функции – название функции + информация о типах аргументов функции
Одинаковые сигнатуры: 	char function (char a, char b);
						int function (char a, char b);
Различные сигнатуры: 	char function (char a, char);
						char function (int a, char b);

    1. Полиморфизм – способность субъекта обрабатывать объекты, не определенные для субъекта на момент его создания (например, возможность функции работать с различными типами данных в качестве аргументов или значения)
    2. Перегрузка функций в C++ - возможность определения в C++ нескольких одноименных функций с различными аргументами (возможны различия в их количестве или/и типе)
Пример: 
Int func (int a)
{
	return(a);
}

Double func (double a)
{
	Return(a);
}

    3. 	Если при вызове функции явно не указано значение аргумента, то оно считается равным заданному по умолчанию:
		Определена функция int Func(int a, int b, int c = 1);
		Вызов Func(0,0); - значение аргумента c равно 1
		Вызов Func(0,0,0); - значение аргумента c равно 0
    4. Шаблоны функций – инструкции, в соответствии с которыми создаются локальные версии функции для заданных параметров и типов данных. Шаблоны позволяют сократить объем текста программы за счет выделения общих элементов в функциях, выполняющих одинаковые действия с разными видами аргументов, и использования этих элементов для каждого из типов соответственно. Отличие шаблонов от функций состоит в том, что при использовании шаблонов, действительный вариант функции создается только в случае вызова функции от конкретных параметров, в то время как при использовании только функций необходимо описать все варианты взаимодействия функций с параметрами отдельно, многократно повторяя схожие фрагменты действий. Ограничения в работе шаблонов состоят в том, что конкретный шаблон может подходить для одних типов данных и не подходить для других, например сложение данных типов int и double можно описать одним шаблоном, но этот шаблон уже не будет корректно описывать сложение, например, структуры комплексных чисел
    5. Явная специализация шаблона – прямое написание функции, отличной от описанной шаблоном, для работы с конкретными типами данных, с которыми, возможно, функция, описанная шаблоном, работала бы некорректно или неэффективно.
	Отличается от обычного шаблона тем, что выполняется только для аргументов конкретного типа
	Пример функции swap:
	Шаблон: 	template <typename T>
		void swap(T &a, T &b)
		{
		T t = a;
		a = b;
		b = t;
		}
Описание структуры section и явная специализация функции swap для struct sction:
		struct section {
		double start, end;
		};

		Template <> void swap<section>(section &a, section &b)
		{
		section t ={};
		t.start = a.start;
		t.end = a.end;
		a.start = b.start	;
		a.end = b.end;
		b.start = t.start;
		b.end = t.end;
		}		
    6. Ссылка – тип данных, являющийся формой указателя, который автоматически разыменовывается при использовании. При объявлении перед именем ссылки ставится символ &, а сама ссылка инициализируется именем переменной, на которую ссылается. Ссылка может указывать на данные любого типа, но этот тип должен совпадать с типом данных ссылочной переменной. 
    7. Ключевое слово inline используется для объявления встроенных функций: при объявлении встроенной функции, ее код копируется в программу в каждом месте, где она вызывается на этапе компиляции с целью ускорения выполнения программы 
    8. Ключевое слово decltype позволяет компилятору самостоятельно определять тип переменной, являющейся результатом выражения:
int a = 1;
int b = 2;
decltype(a + b) c = a + b;
	Ключевое слово auto позволяет компилятору самостоятельно определять тип переменной или возвращаемого значения функции
Пример для переменных:
		int a = 1;
		auto b = a;





